var tipuesearch = {"pages":[{"text":"FIAT FIAT: Fortran Implementation of Abstract Types This library aims to implement various common data structures\nin Fortran.\nThese will be implemented in a generic manner using a container type. This\nwas originally developed in PolyCon ,\nbut has since been folded into FIAT, with some improvements. Data Structures A list of data structures which could be implemented is provided below. [ ] Queue [ ] Double Ended Queue [ ] Priority Queue [ ] Stack [ ] List [ ] Linked List [ ] Array List [ ] Set [ ] Hash Set [ ] Tree Set [ ] Multiset [ ] Hash Multiset [ ] Tree Multiset [ ] Map [ ] Hash Map [ ] Tree Map [ ] Multimap [ ] Hash Multimap [ ] Tree Multimap [ ] Tree [ ] Graph [ ] Digraph This list, while not necessarily meant to be exhaustive, does represent a\nlong-term goal. Initial goals would be to implement queues, stacks, and lists. Inheritance Structure While the absence of interfaces (of the type found in Java) or multiple\ninheritance (as found in C++) somewhat limits the flexibility of these data\nstructures, thought has been put into how best to make these entities useful\nin a polymorphic way. A potential inheritance structure has been mapped out\nin UML using the software Dia . A Dia\nfile is provided in the repository. (Note that,\nas the author of this file is inexperienced with UML, the direction of\ninheritance in the diagram may have accidentally been backwards. In any case,\nthe intended meaning should be clear from the context.) An SVG version of\nthe UML has also been produced, called datastruct.svg . Apologies are\ngiven for the massive size of the diagram and for the uneven level of\nimplementation details which have been added. License FIAT is licensed under the GNU Lesser General Public License (LGPL) v3.0 or\nlater. The terms are provided in the file LICENSE . The LGPL make reference\nto the GNU General Public License (GPL), which is provided in the file GPL .\nIn brief, the LGPL allows this library to be linked to software under any\nlicense (with a few, minor, restrictions). However, should a modified version\nof the library itself be released, it must be licensed under the terms of\nthe LGPL or GPL. Developer Info Chris MacMackin I am a graduate student at the University of Oxford, studying the melting and evolution of ice shelves. I enjoy programming, with my favourite languages being Fortran (for numerical work), Vala (for object-oriented programming and anything involving a GUI), and Python (for scripting and everything else).","tags":"","loc":"index.html","title":" FIAT "},{"text":"Source Code ! !  abstract_container_mod.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module abstract_container_mod !! Author: Chris MacMackin !! Date: December 2015 !! License: LGPLv3 !! !! Provides an abstract container derived type which can be used !! as a sort of unlimited polymorphic entity whose contents are !! retrievable with type-guards. Different subclasses are created !! in order to hold different data-types. See [[container]] for !! instructions on creating concrete subclasses. See [[container_mod]] !! for subclasses containing the built-in data-types. use iso_fortran_env , only : stderr => error_unit , i1 => int8 implicit none private type , abstract :: container !! Author: Chris MacMackin !! Date: December 2015 !! Display: Public !!          Private !! !! An abstract derived type which contains data. This type can be !! used for a sort of unlimited polymorphism. It is extended to !! create different classes capable of holding particular !! data-types. Extensions must implement the procedure !! [[container:typeguard]] in order to provide the ability to !! transfer data out of the container and into a variable. Assuming !! that you are creating a concrete class called !! `example_container`, this should be implemented as follows: !! !!```fortran !! module example_container_mod !! !!   use abstract_container_mod !!   implicit none !!   private !! !!   type example !!     integer, public :: i !!   end type example !! !!   type, extends(container) :: example_container !!   contains !!     private !!     procedure :: typeguard => example_guard !!   end type example_container !! !! contains !! !!   logical function example_guard(this, lhs) result(ret) !!     class(example_container), intent(in) :: this !!     class(*), intent(inout) :: lhs !!     select type(lhs) !!       type is(example) !!         lhs = transfer(this%contents(), lhs) !!         ret = .true. !!       class default !!         ret = .false. !!     end select !!   end function example_guard !! !! end module example_container_mod !!``` private integer ( i1 ), dimension (:), allocatable :: storage !! Variable in which to place data contents logical :: filled = . false . !! `.true.` if container is set, `.false.` otherwise contains private procedure ( guard ), deferred :: typeguard !! Performs the actual transfer of the container's contents to !! another variable. procedure , public :: contents !! Retrieves the contents of the container, in the form of an !! integer array. procedure , public :: set !! Sets the contents of the container. procedure , pass ( rhs ) :: assign_container !! Assigns container contents to another variable. procedure :: is_equal !! Check whether two containers have the same contents. generic , public :: assignment ( = ) => assign_container generic , public :: operator ( == ) => is_equal end type container abstract interface logical function guard ( this , lhs ) import container class ( container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs !! The variable which the container contents are to be !! transferred to. end function guard end interface public :: container contains subroutine assign_container ( lhs , rhs ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the contents of the container to another variable. !! If the other variable is another container of the same type !! then the contents will be transferred. If the other variable is !! the same type as the contents of the container (as determined !! by the [[container:typeguard]] routine provided for that !! concrete type extension) then it will be given the value held by !! the container. Otherwise, an error message will be printed and !! the program stopped. If compiled with `gfortran` then a backtrace !! will also be printed. In the event that the container was never !! set to a value, then this also constitutes an error. class ( * ), intent ( inout ) :: lhs !! The variable which the container contents will be assigned to. class ( container ), intent ( in ) :: rhs !! The container variable. !------------------------------------------------------------------- select type ( lhs ) class is ( container ) if ( same_type_as ( lhs , rhs )) then lhs % storage = rhs % storage return else write ( stderr , * ) \"ERROR: Can not assign to a different container subclass\" #ifdef __GFORTRAN__ call backtrace #endif stop end if class default if ( rhs % filled ) then if ( rhs % typeguard ( lhs )) return write ( stderr , * ) \"ERROR: Can not assign this container's contents to given variable\" #ifdef __GFORTRAN__ call backtrace #endif stop else write ( stderr , * ) \"ERROR: Container is empty.\" #ifdef __GFORTRAN__ call backtrace #endif stop end if end select end subroutine assign_container pure function contents ( this ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Returns the contents, encoded as a character array, of the !! container. class ( container ), intent ( in ) :: this integer ( i1 ), dimension (:), allocatable :: contents contents = this % storage end function contents subroutine set ( this , content ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Sets the contents of the storage array to value passed. The type !! of the variable provided must be the same as the container !! variable is designed to accept (as determined by the !! concrete type implementation of the [[container:typeguard]] !! method in the extension) or be of the same type of container. !! Otherwise an error message will be printed and the program will !! exit. If `gfortran` was used to compile then a backtrace will !! also be printed. !! !! @Warning During the initial phase of writing unit tests for the !! containers, I found that when content is class(container) then !! ~5GB of memory would end up being allocated at line 207. After !! various experiments which involved moving the code around, it !! stopped doing this when I changed it back. I have no idea why !! it works now and suspect that this is a bug with gfortran 5.3.0. class ( container ), intent ( out ) :: this class ( * ), intent ( in ) :: content !! The value to be placed in the container class ( * ), allocatable :: tmp allocate ( tmp , source = content ) if (. not . allocated ( this % storage )) allocate ( this % storage ( 1 )) if ( same_type_as ( this , content )) then select type ( content ) class is ( container ) if ( content % filled ) then this % filled = . true . this % storage = content % storage else this % filled = . false . if ( allocated ( this % storage )) deallocate ( this % storage ) endif return end select else if ( this % typeguard ( tmp )) then this % filled = . true . this % storage = transfer ( content , this % storage ) else write ( stderr , * ) \"ERROR: Can not assign given variable to this container\" #ifdef __GFORTRAN__ call backtrace #endif stop end if end subroutine set elemental logical function is_equal ( lhs , rhs ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Checks whether two containers are of the same type and are !! storing the same contents. class ( container ), intent ( in ) :: lhs , rhs if (. not . same_type_as ( lhs , rhs )) then is_equal = . false . return end if if ((. not . lhs % filled ). and .(. not . rhs % filled )) then is_equal = . true . return end if if ( lhs % filled . neqv . rhs % filled ) then is_equal = . false . return end if is_equal = ( size ( lhs % storage ) == size ( rhs % storage ) . and . & all ( lhs % storage == rhs % storage )) end function is_equal end module abstract_container_mod","tags":"","loc":"sourcefile/abstract_container.f90.html","title":"abstract_container.F90 – FIAT"},{"text":"Source Code ! !  bidir_node.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module bidir_node_mod !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! Implements a node which contains a pointer to two other (the next ! and previous) nodes, allowing a chain to be formed. This can be used ! to, for example, build a doubly-linked lists. ! ! It is not anticipated that the bidir_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. ! use linked_node_mod , only : linked_node implicit none private type , extends ( linked_node ), public :: bidir_node !* Author: Chris MacMackin !  Date: February 2016 ! ! A node which, in addition to holding a value, points at two other ! (the previous and next) bidir_node objects or objects of a ! descendent type. This type can be built up into a chain, allowing ! a doubly-linked list to be formed. ! ! It is not anticipated that the bidir_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. As such, care must ! be taken when using certain methods (see below) to avoid memory ! leaks or segfaults. ! private class ( bidir_node ), pointer :: prev => null () contains procedure :: has_prev procedure :: get_prev procedure :: set_prev procedure :: unset_prev end type bidir_node contains elemental logical function has_prev ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not this node points to a previous one, forming ! a chain in the backwards direction. ! class ( bidir_node ), intent ( in ) :: this has_prev = associated ( this % prev ) end function has_prev function get_prev ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns a pointer to the previous node in the chain. If this node ! does not point at a previous one one, then a null pointer is ! returned. ! class ( bidir_node ), intent ( in ) :: this class ( bidir_node ), pointer :: get_prev if ( this % has_prev ()) then get_prev => this % prev else get_prev => null () end if end function get_prev subroutine set_prev ( this , new_prev , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Sets the pointer to the previous node in the chain. If this node ! already points to a previous one, the pointer will, by default, be ! nullified. This may result in a memory leak. Optionally, by ! setting `deallocate_old=.true.`, the previous node (and all nodes ! it points to) can be deallocated. This may result in a segfault if ! another part of the program tries to access the former previous ! node. The new previous node will not automatically be set to have ! this one as the next, with the same rules applied to deallocation. ! class ( bidir_node ), intent ( inout ) :: this class ( bidir_node ), pointer , intent ( in ) :: new_prev !! The node which will now be previous in the chain. logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! previous nodes in the chain. Defaults to `.false.`. call this % unset_prev ( deallocate_old ) this % prev => new_prev end subroutine set_prev subroutine unset_prev ( this , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Unsets the pointer to the previous node in the chain, severing it. ! By default, the pointer is only nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! previous node (and all previous nodes it points to) can be ! deallocated. This may result in a segfault if another part of the ! program tries to access the former previous node. ! class ( bidir_node ), intent ( inout ) :: this logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! p nodes in the chain. Defaults to `.false.`. if (. not . this % has_prev ()) return if ( present ( deallocate_old )) then if ( deallocate_old ) then call this % prev % unset_prev (. true .) deallocate ( this % prev ) return end if end if nullify ( this % prev ) end subroutine unset_prev end module bidir_node_mod","tags":"","loc":"sourcefile/bidir_node.f90.html","title":"bidir_node.f90 – FIAT"},{"text":"Source Code !  container_mod.f90 ! !  Copyright 2015 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! ! module container_mod !! Author: Chris MacMackin !! Date: December 2015 !! License: LGPLv3 !! !! Provides implementations of the [[container]] abstract !! derived type for all of the intrinsic variable types. use abstract_container_mod , only : container use iso_fortran_env , only : i1 => int8 , i2 => int16 , i4 => int32 , & i8 => int64 , r4 => real32 , r8 => real64 , & r16 => real128 implicit none private type , extends ( container ) :: int_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt integer type. contains private procedure :: typeguard => int_guard end type int_container type , extends ( container ) :: int1_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 1 byte integer type. contains private procedure :: typeguard => int1_guard end type int1_container type , extends ( container ) :: int2_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 2 byte integer type. contains private procedure :: typeguard => int2_guard end type int2_container type , extends ( container ) :: int4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte integer type. contains private procedure :: typeguard => int4_guard end type int4_container type , extends ( container ) :: int8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte integer type. contains private procedure :: typeguard => int8_guard end type int8_container type , extends ( container ) :: real_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt real type. contains private procedure :: typeguard => real_guard end type real_container type , extends ( container ) :: real4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte real type. contains private procedure :: typeguard => real4_guard end type real4_container type , extends ( container ) :: real8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte real type. contains private procedure :: typeguard => real8_guard end type real8_container type , extends ( container ) :: real16_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 16 byte real type. contains private procedure :: typeguard => real16_guard end type real16_container type , extends ( container ) :: complex_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt complex type. contains private procedure :: typeguard => complex_guard end type complex_container type , extends ( container ) :: complex4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte complex type. contains private procedure :: typeguard => complex4_guard end type complex4_container type , extends ( container ) :: complex8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte complex type. contains private procedure :: typeguard => complex8_guard end type complex8_container type , extends ( container ) :: complex16_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 16 byte complex type. contains private procedure :: typeguard => complex16_guard end type complex16_container type , extends ( container ) :: logical_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt logical type. contains private procedure :: typeguard => logical_guard end type logical_container type , extends ( container ) :: character_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt character type. contains private procedure :: typeguard => character_guard end type character_container public :: character_container , complex_container , complex4_container , & complex8_container , complex16_container , int_container , & int1_container , int2_container , int4_container , & int8_container , logical_container , real_container , & real4_container , real8_container , real16_container contains logical function int_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int_guard logical function int1_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int1_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i1 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int1_guard logical function int2_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int2_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i2 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int2_guard logical function int4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int4_guard logical function int8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int8_guard logical function real_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real_guard logical function real4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real4_guard logical function real8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real8_guard logical function real16_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real16_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r16 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real16_guard logical function complex_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex_guard logical function complex4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex4_guard logical function complex8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex8_guard logical function complex16_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex16_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r16 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex16_guard logical function logical_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( logical_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( logical ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function logical_guard logical function character_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( character_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( character ( len =* )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function character_guard end module container_mod","tags":"","loc":"sourcefile/container.f90.html","title":"container.f90 – FIAT"},{"text":"Source Code ! !  countable.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module countable_mod use iterator_mod , only : iterator implicit none private type , extends ( iterator ), abstract , public :: countable contains procedure ( int_func ), deferred :: size end type countable abstract interface function int_func ( this ) import countable class ( countable ), intent ( in ) :: this integer :: int_func end function int_func end interface end module countable_mod","tags":"","loc":"sourcefile/countable.f90.html","title":"countable.f90 – FIAT"},{"text":"Source Code ! !  iterator.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module iterator_mod use abstract_container_mod , only : container implicit none private type , abstract , public :: iterator contains procedure ( has_func ), deferred :: has_next procedure ( next_func ), deferred :: next procedure ( empty_sub ), deferred :: reset procedure ( copy_func ), deferred :: copy end type iterator abstract interface elemental function has_func ( this ) import iterator class ( iterator ), intent ( in ) :: this logical :: has_func end function has_func function next_func ( this ) import iterator import container class ( iterator ), intent ( inout ) :: this class ( container ), allocatable :: next_func end function next_func subroutine empty_sub ( this ) import iterator class ( iterator ), intent ( inout ) :: this end subroutine empty_sub function copy_func ( this ) import iterator class ( iterator ), intent ( in ) :: this class ( iterator ), allocatable :: copy_func end function copy_func end interface end module iterator_mod","tags":"","loc":"sourcefile/iterator.f90.html","title":"iterator.f90 – FIAT"},{"text":"Source Code ! !  linked_node.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module linked_node_mod !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! Implements a node which contains a pointer to another (the next) ! node, allowing a chain to be formed. This can be used to, for ! example, build linked lists. ! ! It is not anticipated that the linked_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. ! use node_mod , only : node implicit none private type , extends ( node ), public :: linked_node !* Author: Chris MacMackin !  Date: February 2016 ! ! A node which, in addition to holding a value, points at another ! (the next) linked_node or descendent type. This type can be built ! up into a chain, allowing a linked list to be formed. ! ! It is not anticipated that the linked_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. As such, care must ! be taken when using certain methods (see below) to avoid memory ! leaks or segfaults. ! private class ( linked_node ), pointer :: next => null () !! The next node in the chain. contains procedure :: has_next !! Checks whether this node points to another one procedure :: get_next !! Returns the next node in the chain if it exists. procedure :: set_next !! Sets the next node in the chain. procedure :: unset_next !! Sets this node not to point at any others, severing the chain. end type linked_node contains elemental logical function has_next ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not this node points at another one, forming ! a chain. ! class ( linked_node ), intent ( in ) :: this has_next = associated ( this % next ) end function has_next function get_next ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns a pointer to the node which this ones points to, i.e. the ! next node in the chain. If this node does not point at another ! one, then a null pointer is returned. ! class ( linked_node ), intent ( in ) :: this class ( linked_node ), pointer :: get_next if ( this % has_next ()) then get_next => this % next else get_next => null () end if end function get_next subroutine set_next ( this , new_next , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Sets the node which this one points to (i.e. sets the next node in ! the chain). If this node already points to another one, the ! pointer will, by default, be nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! next node (and all nodes it points to) can be deallocated. This ! may result in a segfault if another part of the program tries to ! access the former next node. ! class ( linked_node ), intent ( inout ) :: this class ( linked_node ), pointer , intent ( in ) :: new_next !! The node which will now be next in the chain. logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! subsequent nodes in the chain. Defaults to `.false.`. call this % unset_next ( deallocate_old ) this % next => new_next end subroutine set_next subroutine unset_next ( this , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Unsets the pointer to the next node in the chain, severing it. ! By default, the pointer is only nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! next node (and all nodes it points to) can be deallocated. This ! may result in a segfault if another part of the program tries to ! access the former next node. ! class ( linked_node ), intent ( inout ) :: this logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! subsequent nodes in the chain. Defaults to `.false.`. if (. not . this % has_next ()) return if ( present ( deallocate_old )) then if ( deallocate_old ) then call this % next % unset_next (. true .) deallocate ( this % next ) return end if end if nullify ( this % next ) end subroutine unset_next end module linked_node_mod","tags":"","loc":"sourcefile/linked_node.f90.html","title":"linked_node.f90 – FIAT"},{"text":"Source Code ! !  node.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module node_mod !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! Provides a [[node]] data type, for holding some sort of contents. ! While a node itself is unlikely to be very useful, various type ! extensions are also made which are then used to build more complex ! data structures. ! ! It is not anticipated that the node type, or any types extending it, ! will be handled directly by end users of FIAT; they are meant for ! internal use within this package. ! use abstract_container_mod , only : container implicit none private type , public :: node !* Author: Chris MacMackin !  Date: February 2016 ! ! An object which contains a container that can be set to have ! arbitrary contents. While of limited use on its own, various ! derived types exist which are extensions of this one exist and ! are used to build more complex data structures. ! ! It is not anticipated that the node type, or any types extending it, ! will be handled directly by end users of FIAT; they are meant for ! internal use within this package. ! private class ( container ), allocatable :: contents !! Contains the value held in this node. contains procedure , non_overridable :: has_contents !! Evaluates whether contents have been assigned to node. procedure , non_overridable :: get_contents !! Returns the value stored in the node. procedure , non_overridable :: set_contents !! Sets the value to be stored in the node. procedure , non_overridable :: unset_contents !! Removes the record of any value stored in the node. end type node contains elemental logical function has_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not a values has been assigned to the node. ! class ( node ), intent ( in ) :: this has_contents = allocated ( this % contents ) end function has_contents pure function get_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! An accessor returning a [[container]] object storing the value ! placed in the node. If the contents have not been set then an ! unallocated container is returned. ! class ( node ), intent ( in ) :: this class ( container ), allocatable :: get_contents !! The stored in the node. if ( this % has_contents ()) allocate ( get_contents , source = this % contents ) end function get_contents subroutine set_contents ( this , contents ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Places a new value into storage within the node. This value must ! already be heald within an allocatable [[container]]. The actual ! argument will be deallocated after the subroutine call, as its ! allocation is moved to the contents of the node. ! class ( node ), intent ( inout ) :: this class ( container ), intent ( inout ), allocatable :: contents !* The new value to be stored in this node. The actual argument ! will be deallocated during the process of assigning it to the ! node. call this % unset_contents () call move_alloc ( contents , this % contents ) end subroutine set_contents subroutine unset_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Deallocates the value stored within the  node. ! class ( node ), intent ( inout ) :: this if ( this % has_contents ()) deallocate ( this % contents ) end subroutine unset_contents end module node_mod","tags":"","loc":"sourcefile/node.f90.html","title":"node.f90 – FIAT"},{"text":"Source Code ! !  ordered.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module ordered_mod use iterator_mod , only : iterator use countable_mod , only : countable use abstract_container_mod , only : container implicit none private type , extends ( countable ), abstract , public :: ordered contains procedure ( push_sub ), deferred :: push procedure ( pop_func ), deferred :: pop procedure ( peek_func ), deferred :: peek procedure ( blank_sub ), deferred :: clear procedure , private :: array_extend procedure , private :: iterator_extend !~     procedure(concat_func), private, deferred :: concat generic :: extend => array_extend , iterator_extend !~     generic :: operator(//) => concat end type ordered abstract interface subroutine push_sub ( this , item ) import ordered class ( ordered ), intent ( inout ) :: this class ( * ), intent ( in ) :: item end subroutine push_sub function pop_func ( this ) import ordered import container class ( ordered ), intent ( inout ) :: this class ( container ), allocatable :: pop_func end function pop_func function peek_func ( this ) import ordered import container class ( ordered ), intent ( in ) :: this class ( container ), allocatable :: peek_func end function peek_func subroutine blank_sub ( this ) import ordered class ( ordered ), intent ( inout ) :: this end subroutine blank_sub function concat_func ( lhs , rhs ) import ordered class ( ordered ), intent ( in ) :: lhs , rhs class ( ordered ), allocatable :: concat_func end function concat_func end interface contains subroutine array_extend ( this , items ) class ( ordered ), intent ( inout ) :: this !FIXME: I've switched this from dimension(*) to dimension(:) because gfortran does not yet support dimension(*) for unlimited polymorphic variables. Add logic to allow dimension(*) for compilers supporting it, maybe. class ( * ), dimension (:), intent ( in ) :: items integer :: i do i = 1 , size ( items ) call this % push ( items ( i )) end do end subroutine array_extend subroutine iterator_extend ( this , items ) class ( ordered ), intent ( inout ) :: this class ( iterator ), intent ( inout ) :: items call items % reset () do while ( items % has_next ()) call this % push ( items % next ()) end do call items % reset () end subroutine iterator_extend end module ordered_mod","tags":"","loc":"sourcefile/ordered.f90.html","title":"ordered.f90 – FIAT"},{"text":"Source Code ! !  iterator.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module stack_mod use iso_fortran_env , only : stderr => error_unit use iterator_mod , only : iterator use ordered_mod , only : ordered use abstract_container_mod , only : container use linked_node_mod , only : linked_node implicit none private type , extends ( ordered ), public :: stack private class ( container ), allocatable :: container type ( linked_node ), pointer :: head => null () type ( linked_node ), pointer :: iter_pos => null () integer :: num_nodes = 0 contains procedure :: has_next => stack_has_next procedure :: next => stack_next procedure :: reset => stack_reset procedure :: copy => stack_copy procedure :: size => stack_size procedure :: push => stack_push procedure :: pop => stack_pop procedure :: peek => stack_peek procedure :: clear => stack_clear !~     procedure, private :: concat => stack_concat procedure , private :: move_head => stack_move_head final :: stack_final end type stack interface stack module procedure :: constructor end interface stack contains function constructor ( container_obj ) result ( new ) class ( container ), intent ( in ) :: container_obj type ( stack ) :: new allocate ( new % container , mold = container_obj ) new % iter_pos => new % head end function constructor elemental logical function stack_has_next ( this ) class ( stack ), intent ( in ) :: this stack_has_next = associated ( this % iter_pos ) end function stack_has_next function stack_next ( this ) class ( stack ), intent ( inout ) :: this class ( container ), allocatable :: stack_next if (. not . this % has_next ()) then write ( stderr , * ) \"ERROR: Bottom of stack reached.\" #ifdef __GFORTRAN__ call backtrace #endif stop end if allocate ( stack_next , source = this % iter_pos % get_contents ()) if ( this % iter_pos % has_next ()) then this % iter_pos => this % iter_pos % get_next () else this % iter_pos => null () end if end function stack_next subroutine stack_reset ( this ) class ( stack ), intent ( inout ) :: this this % iter_pos => this % head end subroutine stack_reset function stack_copy ( this ) class ( stack ), intent ( in ) :: this class ( iterator ), allocatable :: stack_copy class ( stack ), allocatable :: tmp type ( linked_node ), pointer :: node1 , node2 => null () allocate ( tmp , source = this ) allocate ( node1 , source = this % head ) tmp % head => node1 allocate ( node2 , source = node1 % get_next ()) do while ( associated ( node2 )) call node1 % set_next ( node2 ) nullify ( node1 ) node1 => node2 nullify ( node2 ) allocate ( node2 , source = node1 % get_next ()) end do call move_alloc ( tmp , stack_copy ) end function stack_copy integer function stack_size ( this ) class ( stack ), intent ( in ) :: this stack_size = this % num_nodes end function stack_size subroutine stack_push ( this , item ) class ( stack ), intent ( inout ) :: this class ( * ), intent ( in ) :: item type ( linked_node ), pointer :: newnode class ( container ), allocatable :: newcont allocate ( newnode ) allocate ( newcont , source = this % container ) call newcont % set ( item ) call newnode % set_contents ( newcont ) call newnode % set_next ( this % head ) this % head => newnode this % num_nodes = this % num_nodes + 1 end subroutine stack_push function stack_pop ( this ) result ( item ) class ( stack ), intent ( inout ) :: this class ( container ), allocatable :: item type ( linked_node ), pointer :: tmp item = this % peek () tmp => this % head this % head => this % head % get_next () deallocate ( tmp ) this % num_nodes = this % num_nodes - 1 end function stack_pop subroutine stack_clear ( this ) class ( stack ), intent ( inout ) :: this contains subroutine blank_stack ( s ) class ( stack ), intent ( out ) :: s end subroutine blank_stack end subroutine stack_clear function stack_peek ( this ) result ( item ) class ( stack ), intent ( in ) :: this class ( container ), allocatable :: item item = this % head % get_contents () end function stack_peek !~   function stack_concat(lhs, rhs) !~     class(stack), intent(in) :: lhs, rhs !~     class(ordered), allocatable :: stack_concat !~     type(stack), allocatable :: tmp_concat !~     type(stack) :: tmp_stack !~     type(linked_node), pointer :: tail !~     tmp_stack = lhs%copy() !~     tmp_concat%head => tmp%move_head() !~     if (stack_concat%size() == 0) then !~       tmp_stack = rhs%copy() !~       tmp_concat%head => tmp%move_head() !~     else !~       tail => tmp_concat%head !~       do while(tail%has_next()) !~         tail => tail%get_next() !~       end do !~       tmp_stack = rhs%copy() !~       call tail%set_next(tmp_stack%move_head()) !~     end if !~     nullify(tail) !~     call move_alloc(tmp_concat, stack_concat) !~   end function stack_concat function stack_move_head ( this ) result ( move_head ) class ( stack ), intent ( inout ) :: this type ( linked_node ), pointer :: move_head move_head => this % head nullify ( this % head ) end function stack_move_head subroutine stack_final ( this ) type ( stack ), intent ( inout ) :: this nullify ( this % iter_pos ) call this % head % unset_next (. true .) deallocate ( this % head ) end subroutine stack_final end module stack_mod","tags":"","loc":"sourcefile/stack.f90.html","title":"stack.F90 – FIAT"},{"text":"type, public, abstract :: container An abstract derived type which contains data. This type can be\n used for a sort of unlimited polymorphism. It is extended to\n create different classes capable of holding particular \n data-types. Extensions must implement the procedure typeguard in order to provide the ability to\n transfer data out of the container and into a variable. Assuming\n that you are creating a concrete class called example_container , this should be implemented as follows: module example_container_mod use abstract_container_mod implicit none private type example integer , public :: i end type example type , extends ( container ) :: example_container contains private procedure :: typeguard => example_guard end type example_container contains logical function example_guard ( this , lhs ) result ( ret ) class ( example_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( example ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function example_guard end module example_container_mod Inherited By type~~container~~InheritedByGraph type~container container type~node node type~container->type~node contents type~stack stack type~container->type~stack container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=i1), private, dimension(:), allocatable :: storage Variable in which to place data contents logical, private :: filled = .false. .true. if container is set, .false. otherwise Type-Bound Procedures procedure( guard ), private, deferred :: typeguard Performs the actual transfer of the container's contents to \n another variable. function guard (this, lhs) Prototype Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this class(*), intent(inout) :: lhs The variable which the container contents are to be \n transferred to. Return Value logical procedure, public :: contents Retrieves the contents of the container, in the form of an\n integer array. private pure function contents (this) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this Return Value integer(kind=i1),\n  dimension(:),allocatable Description Author Chris MacMackin Date December 2015 Returns the contents, encoded as a character array, of the \n container. procedure, public :: set Sets the contents of the container. private subroutine set (this, content) Arguments Type Intent Optional Attributes Name class( container ), intent(out) :: this class(*), intent(in) :: content The value to be placed in the container Description Author Chris MacMackin Date December 2015 Sets the contents of the storage array to value passed. The type\n of the variable provided must be the same as the container\n variable is designed to accept (as determined by the\n concrete type implementation of the typeguard method in the extension) or be of the same type of container.\n Otherwise an error message will be printed and the program will \n exit. If gfortran was used to compile then a backtrace will\n also be printed. procedure, private, pass(rhs) :: assign_container Assigns container contents to another variable. private subroutine assign_container (lhs, rhs) Arguments Type Intent Optional Attributes Name class(*), intent(inout) :: lhs The variable which the container contents will be assigned to. class( container ), intent(in) :: rhs The container variable. Description Author Chris MacMackin Date December 2015 Transfers the contents of the container to another variable.\n If the other variable is another container of the same type\n then the contents will be transferred. If the other variable is\n the same type as the contents of the container (as determined\n by the typeguard routine provided for that \n concrete type extension) then it will be given the value held by\n the container. Otherwise, an error message will be printed and \n the program stopped. If compiled with gfortran then a backtrace\n will also be printed. In the event that the container was never\n set to a value, then this also constitutes an error. procedure, private :: is_equal Check whether two containers have the same contents. private elemental function is_equal (lhs, rhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: lhs class( container ), intent(in) :: rhs Return Value logical Description Author Chris MacMackin Date December 2015 Checks whether two containers are of the same type and are\n storing the same contents. generic, public :: assignment(=) => assign_container private subroutine assign_container (lhs, rhs) Arguments Type Intent Optional Attributes Name class(*), intent(inout) :: lhs The variable which the container contents will be assigned to. class( container ), intent(in) :: rhs The container variable. Description Author Chris MacMackin Date December 2015 Transfers the contents of the container to another variable.\n If the other variable is another container of the same type\n then the contents will be transferred. If the other variable is\n the same type as the contents of the container (as determined\n by the typeguard routine provided for that \n concrete type extension) then it will be given the value held by\n the container. Otherwise, an error message will be printed and \n the program stopped. If compiled with gfortran then a backtrace\n will also be printed. In the event that the container was never\n set to a value, then this also constitutes an error. generic, public :: operator(==) => is_equal private elemental function is_equal (lhs, rhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: lhs class( container ), intent(in) :: rhs Return Value logical Description Author Chris MacMackin Date December 2015 Checks whether two containers are of the same type and are\n storing the same contents. Source Code type , abstract :: container !! Author: Chris MacMackin !! Date: December 2015 !! Display: Public !!          Private !! !! An abstract derived type which contains data. This type can be !! used for a sort of unlimited polymorphism. It is extended to !! create different classes capable of holding particular !! data-types. Extensions must implement the procedure !! [[container:typeguard]] in order to provide the ability to !! transfer data out of the container and into a variable. Assuming !! that you are creating a concrete class called !! `example_container`, this should be implemented as follows: !! !!```fortran !! module example_container_mod !! !!   use abstract_container_mod !!   implicit none !!   private !! !!   type example !!     integer, public :: i !!   end type example !! !!   type, extends(container) :: example_container !!   contains !!     private !!     procedure :: typeguard => example_guard !!   end type example_container !! !! contains !! !!   logical function example_guard(this, lhs) result(ret) !!     class(example_container), intent(in) :: this !!     class(*), intent(inout) :: lhs !!     select type(lhs) !!       type is(example) !!         lhs = transfer(this%contents(), lhs) !!         ret = .true. !!       class default !!         ret = .false. !!     end select !!   end function example_guard !! !! end module example_container_mod !!``` private integer ( i1 ), dimension (:), allocatable :: storage !! Variable in which to place data contents logical :: filled = . false . !! `.true.` if container is set, `.false.` otherwise contains private procedure ( guard ), deferred :: typeguard !! Performs the actual transfer of the container's contents to !! another variable. procedure , public :: contents !! Retrieves the contents of the container, in the form of an !! integer array. procedure , public :: set !! Sets the contents of the container. procedure , pass ( rhs ) :: assign_container !! Assigns container contents to another variable. procedure :: is_equal !! Check whether two containers have the same contents. generic , public :: assignment ( = ) => assign_container generic , public :: operator ( == ) => is_equal end type container","tags":"","loc":"type/container.html","title":"container – FIAT "},{"text":"type, public, extends(linked_node) :: bidir_node type~~bidir_node~~InheritsGraph type~bidir_node bidir_node type~bidir_node->type~bidir_node prev linked_node linked_node linked_node->type~bidir_node Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A node which, in addition to holding a value, points at two other\n (the previous and next) bidir_node objects or objects of a\n descendent type. This type can be built up into a chain, allowing\n a doubly-linked list to be formed. It is not anticipated that the bidir_node type, or any types \n extending it, will be handled directly by end users of FIAT; they \n are meant for internal use within this package. As such, care must\n be taken when using certain methods (see below) to avoid memory\n leaks or segfaults. Components Type Visibility Attributes Name Initial class( bidir_node ), private, pointer :: prev => null() Type-Bound Procedures procedure, public :: has_prev private elemental function has_prev (this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not this node points to a previous one, forming\n a chain in the backwards direction. procedure, public :: get_prev private function get_prev (this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value class( bidir_node ),\n  pointer Description Author Chris MacMackin Date February 2016 Returns a pointer to the previous node in the chain. If this node\n does not point at a previous one one, then a null pointer is\n returned. procedure, public :: set_prev private subroutine set_prev (this, new_prev, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this class( bidir_node ), intent(in), pointer :: new_prev The node which will now be previous in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n previous nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Sets the pointer to the previous node in the chain. If this node\n already points to a previous one, the pointer will, by default, be\n nullified. This may result in a memory leak. Optionally, by\n setting deallocate_old=.true. , the previous node (and all nodes\n it points to) can be deallocated. This may result in a segfault if\n another part of the program tries to access the former previous\n node. The new previous node will not automatically be set to have\n this one as the next, with the same rules applied to deallocation. procedure, public :: unset_prev private subroutine unset_prev (this, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n p nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Unsets the pointer to the previous node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n previous node (and all previous nodes it points to) can be\n deallocated. This may result in a segfault if another part of the\n program tries to access the former previous node. Source Code type , extends ( linked_node ), public :: bidir_node !* Author: Chris MacMackin !  Date: February 2016 ! ! A node which, in addition to holding a value, points at two other ! (the previous and next) bidir_node objects or objects of a ! descendent type. This type can be built up into a chain, allowing ! a doubly-linked list to be formed. ! ! It is not anticipated that the bidir_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. As such, care must ! be taken when using certain methods (see below) to avoid memory ! leaks or segfaults. ! private class ( bidir_node ), pointer :: prev => null () contains procedure :: has_prev procedure :: get_prev procedure :: set_prev procedure :: unset_prev end type bidir_node","tags":"","loc":"type/bidir_node.html","title":"bidir_node – FIAT "},{"text":"type, public, extends(container) :: int_container type~~int_container~~InheritsGraph type~int_container int_container container container container->type~int_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the defualt integer type. Type-Bound Procedures procedure, private :: typeguard => int_guard private function int_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: int_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt integer type. contains private procedure :: typeguard => int_guard end type int_container","tags":"","loc":"type/int_container.html","title":"int_container – FIAT "},{"text":"type, public, extends(container) :: int1_container type~~int1_container~~InheritsGraph type~int1_container int1_container container container container->type~int1_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 1 byte integer type. Type-Bound Procedures procedure, private :: typeguard => int1_guard private function int1_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int1_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: int1_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 1 byte integer type. contains private procedure :: typeguard => int1_guard end type int1_container","tags":"","loc":"type/int1_container.html","title":"int1_container – FIAT "},{"text":"type, public, extends(container) :: int2_container type~~int2_container~~InheritsGraph type~int2_container int2_container container container container->type~int2_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 2 byte integer type. Type-Bound Procedures procedure, private :: typeguard => int2_guard private function int2_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int2_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: int2_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 2 byte integer type. contains private procedure :: typeguard => int2_guard end type int2_container","tags":"","loc":"type/int2_container.html","title":"int2_container – FIAT "},{"text":"type, public, extends(container) :: int4_container type~~int4_container~~InheritsGraph type~int4_container int4_container container container container->type~int4_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 4 byte integer type. Type-Bound Procedures procedure, private :: typeguard => int4_guard private function int4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: int4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte integer type. contains private procedure :: typeguard => int4_guard end type int4_container","tags":"","loc":"type/int4_container.html","title":"int4_container – FIAT "},{"text":"type, public, extends(container) :: int8_container type~~int8_container~~InheritsGraph type~int8_container int8_container container container container->type~int8_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 8 byte integer type. Type-Bound Procedures procedure, private :: typeguard => int8_guard private function int8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: int8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte integer type. contains private procedure :: typeguard => int8_guard end type int8_container","tags":"","loc":"type/int8_container.html","title":"int8_container – FIAT "},{"text":"type, public, extends(container) :: real_container type~~real_container~~InheritsGraph type~real_container real_container container container container->type~real_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the defualt real type. Type-Bound Procedures procedure, private :: typeguard => real_guard private function real_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: real_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt real type. contains private procedure :: typeguard => real_guard end type real_container","tags":"","loc":"type/real_container.html","title":"real_container – FIAT "},{"text":"type, public, extends(container) :: real4_container type~~real4_container~~InheritsGraph type~real4_container real4_container container container container->type~real4_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 4 byte real type. Type-Bound Procedures procedure, private :: typeguard => real4_guard private function real4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: real4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte real type. contains private procedure :: typeguard => real4_guard end type real4_container","tags":"","loc":"type/real4_container.html","title":"real4_container – FIAT "},{"text":"type, public, extends(container) :: real8_container type~~real8_container~~InheritsGraph type~real8_container real8_container container container container->type~real8_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 8 byte real type. Type-Bound Procedures procedure, private :: typeguard => real8_guard private function real8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: real8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte real type. contains private procedure :: typeguard => real8_guard end type real8_container","tags":"","loc":"type/real8_container.html","title":"real8_container – FIAT "},{"text":"type, public, extends(container) :: real16_container type~~real16_container~~InheritsGraph type~real16_container real16_container container container container->type~real16_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 16 byte real type. Type-Bound Procedures procedure, private :: typeguard => real16_guard private function real16_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: real16_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 16 byte real type. contains private procedure :: typeguard => real16_guard end type real16_container","tags":"","loc":"type/real16_container.html","title":"real16_container – FIAT "},{"text":"type, public, extends(container) :: complex_container type~~complex_container~~InheritsGraph type~complex_container complex_container container container container->type~complex_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the defualt complex type. Type-Bound Procedures procedure, private :: typeguard => complex_guard private function complex_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: complex_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt complex type. contains private procedure :: typeguard => complex_guard end type complex_container","tags":"","loc":"type/complex_container.html","title":"complex_container – FIAT "},{"text":"type, public, extends(container) :: complex4_container type~~complex4_container~~InheritsGraph type~complex4_container complex4_container container container container->type~complex4_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 4 byte complex type. Type-Bound Procedures procedure, private :: typeguard => complex4_guard private function complex4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: complex4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte complex type. contains private procedure :: typeguard => complex4_guard end type complex4_container","tags":"","loc":"type/complex4_container.html","title":"complex4_container – FIAT "},{"text":"type, public, extends(container) :: complex8_container type~~complex8_container~~InheritsGraph type~complex8_container complex8_container container container container->type~complex8_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 8 byte complex type. Type-Bound Procedures procedure, private :: typeguard => complex8_guard private function complex8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: complex8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte complex type. contains private procedure :: typeguard => complex8_guard end type complex8_container","tags":"","loc":"type/complex8_container.html","title":"complex8_container – FIAT "},{"text":"type, public, extends(container) :: complex16_container type~~complex16_container~~InheritsGraph type~complex16_container complex16_container container container container->type~complex16_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 16 byte complex type. Type-Bound Procedures procedure, private :: typeguard => complex16_guard private function complex16_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: complex16_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 16 byte complex type. contains private procedure :: typeguard => complex16_guard end type complex16_container","tags":"","loc":"type/complex16_container.html","title":"complex16_container – FIAT "},{"text":"type, public, extends(container) :: logical_container type~~logical_container~~InheritsGraph type~logical_container logical_container container container container->type~logical_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the defualt logical type. Type-Bound Procedures procedure, private :: typeguard => logical_guard private function logical_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( logical_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: logical_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt logical type. contains private procedure :: typeguard => logical_guard end type logical_container","tags":"","loc":"type/logical_container.html","title":"logical_container – FIAT "},{"text":"type, public, extends(container) :: character_container type~~character_container~~InheritsGraph type~character_container character_container container container container->type~character_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the defualt character type. Type-Bound Procedures procedure, private :: typeguard => character_guard private function character_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( character_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: character_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt character type. contains private procedure :: typeguard => character_guard end type character_container","tags":"","loc":"type/character_container.html","title":"character_container – FIAT "},{"text":"type, public, abstract, extends(iterator) :: countable type~~countable~~InheritsGraph type~countable countable iterator iterator iterator->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure( int_func ), public, deferred :: size function int_func (this) Prototype Arguments Type Intent Optional Attributes Name class( countable ), intent(in) :: this Return Value integer Source Code type , extends ( iterator ), abstract , public :: countable contains procedure ( int_func ), deferred :: size end type countable","tags":"","loc":"type/countable.html","title":"countable – FIAT "},{"text":"type, public, abstract :: iterator Type-Bound Procedures procedure( has_func ), public, deferred :: has_next elemental function has_func (this) Prototype Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value logical procedure( next_func ), public, deferred :: next function next_func (this) Prototype Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this Return Value class( container ),\n  allocatable procedure( empty_sub ), public, deferred :: reset subroutine empty_sub (this) Prototype Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this procedure( copy_func ), public, deferred :: copy function copy_func (this) Prototype Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value class( iterator ),\n  allocatable Source Code type , abstract , public :: iterator contains procedure ( has_func ), deferred :: has_next procedure ( next_func ), deferred :: next procedure ( empty_sub ), deferred :: reset procedure ( copy_func ), deferred :: copy end type iterator","tags":"","loc":"type/iterator.html","title":"iterator – FIAT "},{"text":"type, public, extends(node) :: linked_node type~~linked_node~~InheritsGraph type~linked_node linked_node type~linked_node->type~linked_node next node node node->type~linked_node Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A node which, in addition to holding a value, points at another\n (the next) linked_node or descendent type. This type can be built\n up into a chain, allowing a linked list to be formed. It is not anticipated that the linked_node type, or any types \n extending it, will be handled directly by end users of FIAT; they \n are meant for internal use within this package. As such, care must\n be taken when using certain methods (see below) to avoid memory\n leaks or segfaults. Inherited By type~~linked_node~~InheritedByGraph type~linked_node linked_node type~linked_node->type~linked_node next type~stack stack type~linked_node->type~stack head, iter_pos Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial class( linked_node ), private, pointer :: next => null() The next node in the chain. Type-Bound Procedures procedure, public :: has_next Checks whether this node points to another one private elemental function has_next (this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not this node points at another one, forming\n a chain. procedure, public :: get_next Returns the next node in the chain if it exists. private function get_next (this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value class( linked_node ),\n  pointer Description Author Chris MacMackin Date February 2016 Returns a pointer to the node which this ones points to, i.e. the\n next node in the chain. If this node does not point at another \n one, then a null pointer is returned. procedure, public :: set_next Sets the next node in the chain. private subroutine set_next (this, new_next, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this class( linked_node ), intent(in), pointer :: new_next The node which will now be next in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Sets the node which this one points to (i.e. sets the next node in\n the chain). If this node already points to another one, the \n pointer will, by default, be nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node. procedure, public :: unset_next Sets this node not to point at any others, severing the chain. private subroutine unset_next (this, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Unsets the pointer to the next node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node. Source Code type , extends ( node ), public :: linked_node !* Author: Chris MacMackin !  Date: February 2016 ! ! A node which, in addition to holding a value, points at another ! (the next) linked_node or descendent type. This type can be built ! up into a chain, allowing a linked list to be formed. ! ! It is not anticipated that the linked_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. As such, care must ! be taken when using certain methods (see below) to avoid memory ! leaks or segfaults. ! private class ( linked_node ), pointer :: next => null () !! The next node in the chain. contains procedure :: has_next !! Checks whether this node points to another one procedure :: get_next !! Returns the next node in the chain if it exists. procedure :: set_next !! Sets the next node in the chain. procedure :: unset_next !! Sets this node not to point at any others, severing the chain. end type linked_node","tags":"","loc":"type/linked_node.html","title":"linked_node – FIAT "},{"text":"type, public :: node type~~node~~InheritsGraph type~node node type~container container type~container->type~node contents Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An object which contains a container that can be set to have\n arbitrary contents. While of limited use on its own, various\n derived types exist which are extensions of this one exist and\n are used to build more complex data structures. It is not anticipated that the node type, or any types extending it,\n will be handled directly by end users of FIAT; they are meant for\n internal use within this package. Components Type Visibility Attributes Name Initial class( container ), private, allocatable :: contents Contains the value held in this node. Type-Bound Procedures procedure, public, non_overridable :: has_contents Evaluates whether contents have been assigned to node. private elemental function has_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not a values has been assigned to the node. procedure, public, non_overridable :: get_contents Returns the value stored in the node. private pure function get_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value class( container ),\n  allocatable The stored in the node. Description Author Chris MacMackin Date February 2016 An accessor returning a container object storing the value\n placed in the node. If the contents have not been set then an\n unallocated container is returned. procedure, public, non_overridable :: set_contents Sets the value to be stored in the node. private subroutine set_contents (this, contents) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this class( container ), intent(inout), allocatable :: contents The new value to be stored in this node. The actual argument\n will be deallocated during the process of assigning it to the\n node. Description Author Chris MacMackin Date February 2016 Places a new value into storage within the node. This value must\n already be heald within an allocatable container . The actual\n argument will be deallocated after the subroutine call, as its\n allocation is moved to the contents of the node. procedure, public, non_overridable :: unset_contents Removes the record of any value stored in the node. private subroutine unset_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this Description Author Chris MacMackin Date February 2016 Deallocates the value stored within the  node. Source Code type , public :: node !* Author: Chris MacMackin !  Date: February 2016 ! ! An object which contains a container that can be set to have ! arbitrary contents. While of limited use on its own, various ! derived types exist which are extensions of this one exist and ! are used to build more complex data structures. ! ! It is not anticipated that the node type, or any types extending it, ! will be handled directly by end users of FIAT; they are meant for ! internal use within this package. ! private class ( container ), allocatable :: contents !! Contains the value held in this node. contains procedure , non_overridable :: has_contents !! Evaluates whether contents have been assigned to node. procedure , non_overridable :: get_contents !! Returns the value stored in the node. procedure , non_overridable :: set_contents !! Sets the value to be stored in the node. procedure , non_overridable :: unset_contents !! Removes the record of any value stored in the node. end type node","tags":"","loc":"type/node.html","title":"node – FIAT "},{"text":"type, public, abstract, extends(countable) :: ordered type~~ordered~~InheritsGraph type~ordered ordered countable countable countable->type~ordered Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure( push_sub ), public, deferred :: push subroutine push_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in) :: item procedure( pop_func ), public, deferred :: pop function pop_func (this) Prototype Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this Return Value class( container ),\n  allocatable procedure( peek_func ), public, deferred :: peek function peek_func (this) Prototype Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: this Return Value class( container ),\n  allocatable procedure( blank_sub ), public, deferred :: clear subroutine blank_sub (this) Prototype Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this procedure, private :: array_extend private subroutine array_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in), dimension(:) :: items procedure, private :: iterator_extend private subroutine iterator_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class( iterator ), intent(inout) :: items generic, public :: extend => array_extend , iterator_extend private subroutine array_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in), dimension(:) :: items private subroutine iterator_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class( iterator ), intent(inout) :: items Source Code type , extends ( countable ), abstract , public :: ordered contains procedure ( push_sub ), deferred :: push procedure ( pop_func ), deferred :: pop procedure ( peek_func ), deferred :: peek procedure ( blank_sub ), deferred :: clear procedure , private :: array_extend procedure , private :: iterator_extend !~     procedure(concat_func), private, deferred :: concat generic :: extend => array_extend , iterator_extend !~     generic :: operator(//) => concat end type ordered","tags":"","loc":"type/ordered.html","title":"ordered – FIAT "},{"text":"type, public, extends(ordered) :: stack type~~stack~~InheritsGraph type~stack stack type~linked_node linked_node type~linked_node->type~stack head, iter_pos type~linked_node->type~linked_node next type~container container type~container->type~stack container node node node->type~linked_node ordered ordered ordered->type~stack Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial class( container ), private, allocatable :: container type( linked_node ), private, pointer :: head => null() type( linked_node ), private, pointer :: iter_pos => null() integer, private :: num_nodes = 0 Constructor private interface stack private function constructor (container_obj) result(new) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: container_obj Return Value type( stack ) Finalization Procedures final :: stack_final private subroutine stack_final (this) Arguments Type Intent Optional Attributes Name type( stack ), intent(inout) :: this Type-Bound Procedures procedure, public :: has_next => stack_has_next private elemental function stack_has_next (this) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: this Return Value logical procedure, public :: next => stack_next private function stack_next (this) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this Return Value class( container ),\n  allocatable procedure, public :: reset => stack_reset private subroutine stack_reset (this) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this procedure, public :: copy => stack_copy private function stack_copy (this) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: this Return Value class( iterator ),\n  allocatable procedure, public :: size => stack_size private function stack_size (this) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: this Return Value integer procedure, public :: push => stack_push private subroutine stack_push (this, item) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this class(*), intent(in) :: item procedure, public :: pop => stack_pop private function stack_pop (this) result(item) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this Return Value class( container ),\n  allocatable procedure, public :: peek => stack_peek private function stack_peek (this) result(item) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: this Return Value class( container ),\n  allocatable procedure, public :: clear => stack_clear private subroutine stack_clear (this) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this procedure, private :: move_head => stack_move_head private function stack_move_head (this) result(move_head) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this Return Value type( linked_node ),\n  pointer Source Code type , extends ( ordered ), public :: stack private class ( container ), allocatable :: container type ( linked_node ), pointer :: head => null () type ( linked_node ), pointer :: iter_pos => null () integer :: num_nodes = 0 contains procedure :: has_next => stack_has_next procedure :: next => stack_next procedure :: reset => stack_reset procedure :: copy => stack_copy procedure :: size => stack_size procedure :: push => stack_push procedure :: pop => stack_pop procedure :: peek => stack_peek procedure :: clear => stack_clear !~     procedure, private :: concat => stack_concat procedure , private :: move_head => stack_move_head final :: stack_final end type stack","tags":"","loc":"type/stack.html","title":"stack – FIAT "},{"text":"abstract interface private function guard(this, lhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this class(*), intent(inout) :: lhs The variable which the container contents are to be \n transferred to. Return Value logical","tags":"","loc":"interface/guard.html","title":"guard – FIAT"},{"text":"abstract interface private function int_func(this) Arguments Type Intent Optional Attributes Name class( countable ), intent(in) :: this Return Value integer","tags":"","loc":"interface/int_func.html","title":"int_func – FIAT"},{"text":"abstract interface private subroutine empty_sub(this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this","tags":"","loc":"interface/empty_sub.html","title":"empty_sub – FIAT"},{"text":"abstract interface private elemental function has_func(this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value logical","tags":"","loc":"interface/has_func.html","title":"has_func – FIAT"},{"text":"abstract interface private function next_func(this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this Return Value class( container ),\n  allocatable","tags":"","loc":"interface/next_func.html","title":"next_func – FIAT"},{"text":"abstract interface private function copy_func(this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value class( iterator ),\n  allocatable","tags":"","loc":"interface/copy_func.html","title":"copy_func – FIAT"},{"text":"abstract interface private subroutine push_sub(this, item) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in) :: item","tags":"","loc":"interface/push_sub.html","title":"push_sub – FIAT"},{"text":"abstract interface private subroutine blank_sub(this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this","tags":"","loc":"interface/blank_sub.html","title":"blank_sub – FIAT"},{"text":"abstract interface private function pop_func(this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this Return Value class( container ),\n  allocatable","tags":"","loc":"interface/pop_func.html","title":"pop_func – FIAT"},{"text":"abstract interface private function peek_func(this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: this Return Value class( container ),\n  allocatable","tags":"","loc":"interface/peek_func.html","title":"peek_func – FIAT"},{"text":"abstract interface private function concat_func(lhs, rhs) Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: lhs class( ordered ), intent(in) :: rhs Return Value class( ordered ),\n  allocatable","tags":"","loc":"interface/concat_func.html","title":"concat_func – FIAT"},{"text":"private pure function contents(this) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this Return Value integer(kind=i1),\n  dimension(:),allocatable Description Returns the contents, encoded as a character array, of the \n container. Source Code pure function contents ( this ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Returns the contents, encoded as a character array, of the !! container. class ( container ), intent ( in ) :: this integer ( i1 ), dimension (:), allocatable :: contents contents = this % storage end function contents","tags":"","loc":"proc/contents.html","title":"contents – FIAT"},{"text":"private elemental function is_equal(lhs, rhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: lhs class( container ), intent(in) :: rhs Return Value logical Description Checks whether two containers are of the same type and are\n storing the same contents. Source Code elemental logical function is_equal ( lhs , rhs ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Checks whether two containers are of the same type and are !! storing the same contents. class ( container ), intent ( in ) :: lhs , rhs if (. not . same_type_as ( lhs , rhs )) then is_equal = . false . return end if if ((. not . lhs % filled ). and .(. not . rhs % filled )) then is_equal = . true . return end if if ( lhs % filled . neqv . rhs % filled ) then is_equal = . false . return end if is_equal = ( size ( lhs % storage ) == size ( rhs % storage ) . and . & all ( lhs % storage == rhs % storage )) end function is_equal","tags":"","loc":"proc/is_equal.html","title":"is_equal – FIAT"},{"text":"private subroutine assign_container(lhs, rhs) Arguments Type Intent Optional Attributes Name class(*), intent(inout) :: lhs The variable which the container contents will be assigned to. class( container ), intent(in) :: rhs The container variable. Description Transfers the contents of the container to another variable.\n If the other variable is another container of the same type\n then the contents will be transferred. If the other variable is\n the same type as the contents of the container (as determined\n by the typeguard routine provided for that \n concrete type extension) then it will be given the value held by\n the container. Otherwise, an error message will be printed and \n the program stopped. If compiled with gfortran then a backtrace\n will also be printed. In the event that the container was never\n set to a value, then this also constitutes an error. Source Code subroutine assign_container ( lhs , rhs ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the contents of the container to another variable. !! If the other variable is another container of the same type !! then the contents will be transferred. If the other variable is !! the same type as the contents of the container (as determined !! by the [[container:typeguard]] routine provided for that !! concrete type extension) then it will be given the value held by !! the container. Otherwise, an error message will be printed and !! the program stopped. If compiled with `gfortran` then a backtrace !! will also be printed. In the event that the container was never !! set to a value, then this also constitutes an error. class ( * ), intent ( inout ) :: lhs !! The variable which the container contents will be assigned to. class ( container ), intent ( in ) :: rhs !! The container variable. !------------------------------------------------------------------- select type ( lhs ) class is ( container ) if ( same_type_as ( lhs , rhs )) then lhs % storage = rhs % storage return else write ( stderr , * ) \"ERROR: Can not assign to a different container subclass\" #ifdef __GFORTRAN__ call backtrace #endif stop end if class default if ( rhs % filled ) then if ( rhs % typeguard ( lhs )) return write ( stderr , * ) \"ERROR: Can not assign this container's contents to given variable\" #ifdef __GFORTRAN__ call backtrace #endif stop else write ( stderr , * ) \"ERROR: Container is empty.\" #ifdef __GFORTRAN__ call backtrace #endif stop end if end select end subroutine assign_container","tags":"","loc":"proc/assign_container.html","title":"assign_container – FIAT"},{"text":"private subroutine set(this, content) Arguments Type Intent Optional Attributes Name class( container ), intent(out) :: this class(*), intent(in) :: content The value to be placed in the container Description Sets the contents of the storage array to value passed. The type\n of the variable provided must be the same as the container\n variable is designed to accept (as determined by the\n concrete type implementation of the typeguard method in the extension) or be of the same type of container.\n Otherwise an error message will be printed and the program will \n exit. If gfortran was used to compile then a backtrace will\n also be printed. Warning During the initial phase of writing unit tests for the \n containers, I found that when content is class(container) then\n ~5GB of memory would end up being allocated at line 207. After\n various experiments which involved moving the code around, it\n stopped doing this when I changed it back. I have no idea why\n it works now and suspect that this is a bug with gfortran 5.3.0. Variables Type Visibility Attributes Name Initial class(*), public, allocatable :: tmp Source Code subroutine set ( this , content ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Sets the contents of the storage array to value passed. The type !! of the variable provided must be the same as the container !! variable is designed to accept (as determined by the !! concrete type implementation of the [[container:typeguard]] !! method in the extension) or be of the same type of container. !! Otherwise an error message will be printed and the program will !! exit. If `gfortran` was used to compile then a backtrace will !! also be printed. !! !! @Warning During the initial phase of writing unit tests for the !! containers, I found that when content is class(container) then !! ~5GB of memory would end up being allocated at line 207. After !! various experiments which involved moving the code around, it !! stopped doing this when I changed it back. I have no idea why !! it works now and suspect that this is a bug with gfortran 5.3.0. class ( container ), intent ( out ) :: this class ( * ), intent ( in ) :: content !! The value to be placed in the container class ( * ), allocatable :: tmp allocate ( tmp , source = content ) if (. not . allocated ( this % storage )) allocate ( this % storage ( 1 )) if ( same_type_as ( this , content )) then select type ( content ) class is ( container ) if ( content % filled ) then this % filled = . true . this % storage = content % storage else this % filled = . false . if ( allocated ( this % storage )) deallocate ( this % storage ) endif return end select else if ( this % typeguard ( tmp )) then this % filled = . true . this % storage = transfer ( content , this % storage ) else write ( stderr , * ) \"ERROR: Can not assign given variable to this container\" #ifdef __GFORTRAN__ call backtrace #endif stop end if end subroutine set","tags":"","loc":"proc/set.html","title":"set – FIAT"},{"text":"private elemental function has_prev(this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value logical Description Returns whether or not this node points to a previous one, forming\n a chain in the backwards direction. Source Code elemental logical function has_prev ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not this node points to a previous one, forming ! a chain in the backwards direction. ! class ( bidir_node ), intent ( in ) :: this has_prev = associated ( this % prev ) end function has_prev","tags":"","loc":"proc/has_prev.html","title":"has_prev – FIAT"},{"text":"private function get_prev(this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value class( bidir_node ),\n  pointer Description Returns a pointer to the previous node in the chain. If this node\n does not point at a previous one one, then a null pointer is\n returned. Source Code function get_prev ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns a pointer to the previous node in the chain. If this node ! does not point at a previous one one, then a null pointer is ! returned. ! class ( bidir_node ), intent ( in ) :: this class ( bidir_node ), pointer :: get_prev if ( this % has_prev ()) then get_prev => this % prev else get_prev => null () end if end function get_prev","tags":"","loc":"proc/get_prev.html","title":"get_prev – FIAT"},{"text":"private subroutine set_prev(this, new_prev, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this class( bidir_node ), intent(in), pointer :: new_prev The node which will now be previous in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n previous nodes in the chain. Defaults to .false. . Description Sets the pointer to the previous node in the chain. If this node\n already points to a previous one, the pointer will, by default, be\n nullified. This may result in a memory leak. Optionally, by\n setting deallocate_old=.true. , the previous node (and all nodes\n it points to) can be deallocated. This may result in a segfault if\n another part of the program tries to access the former previous\n node. The new previous node will not automatically be set to have\n this one as the next, with the same rules applied to deallocation. Source Code subroutine set_prev ( this , new_prev , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Sets the pointer to the previous node in the chain. If this node ! already points to a previous one, the pointer will, by default, be ! nullified. This may result in a memory leak. Optionally, by ! setting `deallocate_old=.true.`, the previous node (and all nodes ! it points to) can be deallocated. This may result in a segfault if ! another part of the program tries to access the former previous ! node. The new previous node will not automatically be set to have ! this one as the next, with the same rules applied to deallocation. ! class ( bidir_node ), intent ( inout ) :: this class ( bidir_node ), pointer , intent ( in ) :: new_prev !! The node which will now be previous in the chain. logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! previous nodes in the chain. Defaults to `.false.`. call this % unset_prev ( deallocate_old ) this % prev => new_prev end subroutine set_prev","tags":"","loc":"proc/set_prev.html","title":"set_prev – FIAT"},{"text":"private subroutine unset_prev(this, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n p nodes in the chain. Defaults to .false. . Description Unsets the pointer to the previous node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n previous node (and all previous nodes it points to) can be\n deallocated. This may result in a segfault if another part of the\n program tries to access the former previous node. Source Code subroutine unset_prev ( this , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Unsets the pointer to the previous node in the chain, severing it. ! By default, the pointer is only nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! previous node (and all previous nodes it points to) can be ! deallocated. This may result in a segfault if another part of the ! program tries to access the former previous node. ! class ( bidir_node ), intent ( inout ) :: this logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! p nodes in the chain. Defaults to `.false.`. if (. not . this % has_prev ()) return if ( present ( deallocate_old )) then if ( deallocate_old ) then call this % prev % unset_prev (. true .) deallocate ( this % prev ) return end if end if nullify ( this % prev ) end subroutine unset_prev","tags":"","loc":"proc/unset_prev.html","title":"unset_prev – FIAT"},{"text":"private function int_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function int_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int_guard","tags":"","loc":"proc/int_guard.html","title":"int_guard – FIAT"},{"text":"private function int1_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int1_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function int1_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int1_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i1 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int1_guard","tags":"","loc":"proc/int1_guard.html","title":"int1_guard – FIAT"},{"text":"private function int2_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int2_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function int2_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int2_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i2 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int2_guard","tags":"","loc":"proc/int2_guard.html","title":"int2_guard – FIAT"},{"text":"private function int4_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function int4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int4_guard","tags":"","loc":"proc/int4_guard.html","title":"int4_guard – FIAT"},{"text":"private function int8_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function int8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int8_guard","tags":"","loc":"proc/int8_guard.html","title":"int8_guard – FIAT"},{"text":"private function real_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function real_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real_guard","tags":"","loc":"proc/real_guard.html","title":"real_guard – FIAT"},{"text":"private function real4_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function real4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real4_guard","tags":"","loc":"proc/real4_guard.html","title":"real4_guard – FIAT"},{"text":"private function real8_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function real8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real8_guard","tags":"","loc":"proc/real8_guard.html","title":"real8_guard – FIAT"},{"text":"private function real16_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function real16_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real16_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r16 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real16_guard","tags":"","loc":"proc/real16_guard.html","title":"real16_guard – FIAT"},{"text":"private function complex_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function complex_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex_guard","tags":"","loc":"proc/complex_guard.html","title":"complex_guard – FIAT"},{"text":"private function complex4_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function complex4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex4_guard","tags":"","loc":"proc/complex4_guard.html","title":"complex4_guard – FIAT"},{"text":"private function complex8_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function complex8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex8_guard","tags":"","loc":"proc/complex8_guard.html","title":"complex8_guard – FIAT"},{"text":"private function complex16_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function complex16_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex16_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r16 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex16_guard","tags":"","loc":"proc/complex16_guard.html","title":"complex16_guard – FIAT"},{"text":"private function logical_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( logical_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function logical_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( logical_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( logical ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function logical_guard","tags":"","loc":"proc/logical_guard.html","title":"logical_guard – FIAT"},{"text":"private function character_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( character_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function character_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( character_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( character ( len =* )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function character_guard","tags":"","loc":"proc/character_guard.html","title":"character_guard – FIAT"},{"text":"private elemental function has_next(this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value logical Description Returns whether or not this node points at another one, forming\n a chain. Source Code elemental logical function has_next ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not this node points at another one, forming ! a chain. ! class ( linked_node ), intent ( in ) :: this has_next = associated ( this % next ) end function has_next","tags":"","loc":"proc/has_next.html","title":"has_next – FIAT"},{"text":"private function get_next(this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value class( linked_node ),\n  pointer Description Returns a pointer to the node which this ones points to, i.e. the\n next node in the chain. If this node does not point at another \n one, then a null pointer is returned. Source Code function get_next ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns a pointer to the node which this ones points to, i.e. the ! next node in the chain. If this node does not point at another ! one, then a null pointer is returned. ! class ( linked_node ), intent ( in ) :: this class ( linked_node ), pointer :: get_next if ( this % has_next ()) then get_next => this % next else get_next => null () end if end function get_next","tags":"","loc":"proc/get_next.html","title":"get_next – FIAT"},{"text":"private subroutine set_next(this, new_next, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this class( linked_node ), intent(in), pointer :: new_next The node which will now be next in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Sets the node which this one points to (i.e. sets the next node in\n the chain). If this node already points to another one, the \n pointer will, by default, be nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node. Source Code subroutine set_next ( this , new_next , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Sets the node which this one points to (i.e. sets the next node in ! the chain). If this node already points to another one, the ! pointer will, by default, be nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! next node (and all nodes it points to) can be deallocated. This ! may result in a segfault if another part of the program tries to ! access the former next node. ! class ( linked_node ), intent ( inout ) :: this class ( linked_node ), pointer , intent ( in ) :: new_next !! The node which will now be next in the chain. logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! subsequent nodes in the chain. Defaults to `.false.`. call this % unset_next ( deallocate_old ) this % next => new_next end subroutine set_next","tags":"","loc":"proc/set_next.html","title":"set_next – FIAT"},{"text":"private subroutine unset_next(this, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Unsets the pointer to the next node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node. Source Code subroutine unset_next ( this , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Unsets the pointer to the next node in the chain, severing it. ! By default, the pointer is only nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! next node (and all nodes it points to) can be deallocated. This ! may result in a segfault if another part of the program tries to ! access the former next node. ! class ( linked_node ), intent ( inout ) :: this logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! subsequent nodes in the chain. Defaults to `.false.`. if (. not . this % has_next ()) return if ( present ( deallocate_old )) then if ( deallocate_old ) then call this % next % unset_next (. true .) deallocate ( this % next ) return end if end if nullify ( this % next ) end subroutine unset_next","tags":"","loc":"proc/unset_next.html","title":"unset_next – FIAT"},{"text":"private elemental function has_contents(this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value logical Description Returns whether or not a values has been assigned to the node. Source Code elemental logical function has_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not a values has been assigned to the node. ! class ( node ), intent ( in ) :: this has_contents = allocated ( this % contents ) end function has_contents","tags":"","loc":"proc/has_contents.html","title":"has_contents – FIAT"},{"text":"private pure function get_contents(this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value class( container ),\n  allocatable The stored in the node. Description An accessor returning a container object storing the value\n placed in the node. If the contents have not been set then an\n unallocated container is returned. Source Code pure function get_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! An accessor returning a [[container]] object storing the value ! placed in the node. If the contents have not been set then an ! unallocated container is returned. ! class ( node ), intent ( in ) :: this class ( container ), allocatable :: get_contents !! The stored in the node. if ( this % has_contents ()) allocate ( get_contents , source = this % contents ) end function get_contents","tags":"","loc":"proc/get_contents.html","title":"get_contents – FIAT"},{"text":"private subroutine set_contents(this, contents) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this class( container ), intent(inout), allocatable :: contents The new value to be stored in this node. The actual argument\n will be deallocated during the process of assigning it to the\n node. Description Places a new value into storage within the node. This value must\n already be heald within an allocatable container . The actual\n argument will be deallocated after the subroutine call, as its\n allocation is moved to the contents of the node. Source Code subroutine set_contents ( this , contents ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Places a new value into storage within the node. This value must ! already be heald within an allocatable [[container]]. The actual ! argument will be deallocated after the subroutine call, as its ! allocation is moved to the contents of the node. ! class ( node ), intent ( inout ) :: this class ( container ), intent ( inout ), allocatable :: contents !* The new value to be stored in this node. The actual argument ! will be deallocated during the process of assigning it to the ! node. call this % unset_contents () call move_alloc ( contents , this % contents ) end subroutine set_contents","tags":"","loc":"proc/set_contents.html","title":"set_contents – FIAT"},{"text":"private subroutine unset_contents(this) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this Description Deallocates the value stored within the  node. Source Code subroutine unset_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Deallocates the value stored within the  node. ! class ( node ), intent ( inout ) :: this if ( this % has_contents ()) deallocate ( this % contents ) end subroutine unset_contents","tags":"","loc":"proc/unset_contents.html","title":"unset_contents – FIAT"},{"text":"private subroutine array_extend(this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in), dimension(:) :: items Variables Type Visibility Attributes Name Initial integer, public :: i Source Code subroutine array_extend ( this , items ) class ( ordered ), intent ( inout ) :: this !FIXME: I've switched this from dimension(*) to dimension(:) because gfortran does not yet support dimension(*) for unlimited polymorphic variables. Add logic to allow dimension(*) for compilers supporting it, maybe. class ( * ), dimension (:), intent ( in ) :: items integer :: i do i = 1 , size ( items ) call this % push ( items ( i )) end do end subroutine array_extend","tags":"","loc":"proc/array_extend.html","title":"array_extend – FIAT"},{"text":"private subroutine iterator_extend(this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class( iterator ), intent(inout) :: items Source Code subroutine iterator_extend ( this , items ) class ( ordered ), intent ( inout ) :: this class ( iterator ), intent ( inout ) :: items call items % reset () do while ( items % has_next ()) call this % push ( items % next ()) end do call items % reset () end subroutine iterator_extend","tags":"","loc":"proc/iterator_extend.html","title":"iterator_extend – FIAT"},{"text":"private function constructor(container_obj) result(new) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: container_obj Return Value type( stack ) Called By proc~~constructor~~CalledByGraph proc~constructor constructor interface~stack stack interface~stack->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function constructor ( container_obj ) result ( new ) class ( container ), intent ( in ) :: container_obj type ( stack ) :: new allocate ( new % container , mold = container_obj ) new % iter_pos => new % head end function constructor","tags":"","loc":"proc/constructor.html","title":"constructor – FIAT"},{"text":"private elemental function stack_has_next(this) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: this Return Value logical Source Code elemental logical function stack_has_next ( this ) class ( stack ), intent ( in ) :: this stack_has_next = associated ( this % iter_pos ) end function stack_has_next","tags":"","loc":"proc/stack_has_next.html","title":"stack_has_next – FIAT"},{"text":"private function stack_next(this) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this Return Value class( container ),\n  allocatable Source Code function stack_next ( this ) class ( stack ), intent ( inout ) :: this class ( container ), allocatable :: stack_next if (. not . this % has_next ()) then write ( stderr , * ) \"ERROR: Bottom of stack reached.\" #ifdef __GFORTRAN__ call backtrace #endif stop end if allocate ( stack_next , source = this % iter_pos % get_contents ()) if ( this % iter_pos % has_next ()) then this % iter_pos => this % iter_pos % get_next () else this % iter_pos => null () end if end function stack_next","tags":"","loc":"proc/stack_next.html","title":"stack_next – FIAT"},{"text":"private function stack_copy(this) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: this Return Value class( iterator ),\n  allocatable Variables Type Visibility Attributes Name Initial class( stack ), public, allocatable :: tmp type( linked_node ), public, pointer :: node1 type( linked_node ), public, pointer :: node2 => null() Source Code function stack_copy ( this ) class ( stack ), intent ( in ) :: this class ( iterator ), allocatable :: stack_copy class ( stack ), allocatable :: tmp type ( linked_node ), pointer :: node1 , node2 => null () allocate ( tmp , source = this ) allocate ( node1 , source = this % head ) tmp % head => node1 allocate ( node2 , source = node1 % get_next ()) do while ( associated ( node2 )) call node1 % set_next ( node2 ) nullify ( node1 ) node1 => node2 nullify ( node2 ) allocate ( node2 , source = node1 % get_next ()) end do call move_alloc ( tmp , stack_copy ) end function stack_copy","tags":"","loc":"proc/stack_copy.html","title":"stack_copy – FIAT"},{"text":"private function stack_size(this) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: this Return Value integer Source Code integer function stack_size ( this ) class ( stack ), intent ( in ) :: this stack_size = this % num_nodes end function stack_size","tags":"","loc":"proc/stack_size.html","title":"stack_size – FIAT"},{"text":"private function stack_pop(this) result(item) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this Return Value class( container ),\n  allocatable Variables Type Visibility Attributes Name Initial type( linked_node ), public, pointer :: tmp Source Code function stack_pop ( this ) result ( item ) class ( stack ), intent ( inout ) :: this class ( container ), allocatable :: item type ( linked_node ), pointer :: tmp item = this % peek () tmp => this % head this % head => this % head % get_next () deallocate ( tmp ) this % num_nodes = this % num_nodes - 1 end function stack_pop","tags":"","loc":"proc/stack_pop.html","title":"stack_pop – FIAT"},{"text":"private function stack_peek(this) result(item) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: this Return Value class( container ),\n  allocatable Source Code function stack_peek ( this ) result ( item ) class ( stack ), intent ( in ) :: this class ( container ), allocatable :: item item = this % head % get_contents () end function stack_peek","tags":"","loc":"proc/stack_peek.html","title":"stack_peek – FIAT"},{"text":"private function stack_move_head(this) result(move_head) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this Return Value type( linked_node ),\n  pointer Source Code function stack_move_head ( this ) result ( move_head ) class ( stack ), intent ( inout ) :: this type ( linked_node ), pointer :: move_head move_head => this % head nullify ( this % head ) end function stack_move_head","tags":"","loc":"proc/stack_move_head.html","title":"stack_move_head – FIAT"},{"text":"private subroutine stack_reset(this) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this Source Code subroutine stack_reset ( this ) class ( stack ), intent ( inout ) :: this this % iter_pos => this % head end subroutine stack_reset","tags":"","loc":"proc/stack_reset.html","title":"stack_reset – FIAT"},{"text":"private subroutine stack_push(this, item) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this class(*), intent(in) :: item Variables Type Visibility Attributes Name Initial type( linked_node ), public, pointer :: newnode class( container ), public, allocatable :: newcont Source Code subroutine stack_push ( this , item ) class ( stack ), intent ( inout ) :: this class ( * ), intent ( in ) :: item type ( linked_node ), pointer :: newnode class ( container ), allocatable :: newcont allocate ( newnode ) allocate ( newcont , source = this % container ) call newcont % set ( item ) call newnode % set_contents ( newcont ) call newnode % set_next ( this % head ) this % head => newnode this % num_nodes = this % num_nodes + 1 end subroutine stack_push","tags":"","loc":"proc/stack_push.html","title":"stack_push – FIAT"},{"text":"private subroutine stack_clear(this) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: this Subroutines subroutine blank_stack(s) Arguments Type Intent Optional Attributes Name class( stack ), intent(out) :: s Source Code subroutine stack_clear ( this ) class ( stack ), intent ( inout ) :: this contains subroutine blank_stack ( s ) class ( stack ), intent ( out ) :: s end subroutine blank_stack end subroutine stack_clear","tags":"","loc":"proc/stack_clear.html","title":"stack_clear – FIAT"},{"text":"private subroutine stack_final(this) Arguments Type Intent Optional Attributes Name type( stack ), intent(inout) :: this Source Code subroutine stack_final ( this ) type ( stack ), intent ( inout ) :: this nullify ( this % iter_pos ) call this % head % unset_next (. true .) deallocate ( this % head ) end subroutine stack_final","tags":"","loc":"proc/stack_final.html","title":"stack_final – FIAT"},{"text":"private interface stack Calls interface~~stack~~CallsGraph interface~stack stack proc~constructor constructor interface~stack->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function constructor (container_obj) result(new) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: container_obj Return Value type( stack )","tags":"","loc":"interface/stack.html","title":"stack – FIAT"},{"text":"Uses: iso_fortran_env module~~abstract_container_mod~~UsesGraph module~abstract_container_mod abstract_container_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract container derived type which can be used \n as a sort of unlimited polymorphic entity whose contents are\n retrievable with type-guards. Different subclasses are created\n in order to hold different data-types. See container for \n instructions on creating concrete subclasses. See container_mod for subclasses containing the built-in data-types. Used By module~~abstract_container_mod~~UsedByGraph module~abstract_container_mod abstract_container_mod module~node_mod node_mod module~abstract_container_mod->module~node_mod module~stack_mod stack_mod module~abstract_container_mod->module~stack_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~ordered_mod ordered_mod module~abstract_container_mod->module~ordered_mod module~container_mod container_mod module~abstract_container_mod->module~container_mod module~linked_node_mod linked_node_mod module~node_mod->module~linked_node_mod module~iterator_mod->module~stack_mod module~iterator_mod->module~ordered_mod module~countable_mod countable_mod module~iterator_mod->module~countable_mod module~ordered_mod->module~stack_mod module~linked_node_mod->module~stack_mod module~bidir_node_mod bidir_node_mod module~linked_node_mod->module~bidir_node_mod module~countable_mod->module~ordered_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private function guard (this, lhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this class(*), intent(inout) :: lhs The variable which the container contents are to be \n transferred to. Return Value logical Derived Types type, public, abstract :: container Components Type Visibility Attributes Name Initial integer(kind=i1), private, dimension(:), allocatable :: storage Variable in which to place data contents logical, private :: filled = .false. .true. if container is set, .false. otherwise Type-Bound Procedures procedure(guard), private, deferred :: typeguard Performs the actual transfer of the container's contents to \n another variable. procedure, public :: contents Retrieves the contents of the container, in the form of an\n integer array. procedure, public :: set Sets the contents of the container. procedure, private, pass(rhs) :: assign_container Assigns container contents to another variable. procedure, private :: is_equal Check whether two containers have the same contents. generic, public :: assignment(=) => assign_container generic, public :: operator(==) => is_equal Description An abstract derived type which contains data. This type can be\n used for a sort of unlimited polymorphism. It is extended to\n create different classes capable of holding particular \n data-types. Extensions must implement the procedure typeguard in order to provide the ability to\n transfer data out of the container and into a variable. Assuming\n that you are creating a concrete class called example_container , this should be implemented as follows: Functions private pure function contents (this) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this Return Value integer(kind=i1),\n  dimension(:),allocatable Description Author Chris MacMackin Date December 2015 Returns the contents, encoded as a character array, of the \n container. private elemental function is_equal (lhs, rhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: lhs class( container ), intent(in) :: rhs Return Value logical Description Author Chris MacMackin Date December 2015 Checks whether two containers are of the same type and are\n storing the same contents. Subroutines private subroutine assign_container (lhs, rhs) Arguments Type Intent Optional Attributes Name class(*), intent(inout) :: lhs The variable which the container contents will be assigned to. class( container ), intent(in) :: rhs The container variable. Description Author Chris MacMackin Date December 2015 Transfers the contents of the container to another variable.\n If the other variable is another container of the same type\n then the contents will be transferred. If the other variable is\n the same type as the contents of the container (as determined\n by the typeguard routine provided for that \n concrete type extension) then it will be given the value held by\n the container. Otherwise, an error message will be printed and \n the program stopped. If compiled with gfortran then a backtrace\n will also be printed. In the event that the container was never\n set to a value, then this also constitutes an error. private subroutine set (this, content) Arguments Type Intent Optional Attributes Name class( container ), intent(out) :: this class(*), intent(in) :: content The value to be placed in the container Description Author Chris MacMackin Date December 2015 Sets the contents of the storage array to value passed. The type\n of the variable provided must be the same as the container\n variable is designed to accept (as determined by the\n concrete type implementation of the typeguard method in the extension) or be of the same type of container.\n Otherwise an error message will be printed and the program will \n exit. If gfortran was used to compile then a backtrace will\n also be printed.","tags":"","loc":"module/abstract_container_mod.html","title":"abstract_container_mod – FIAT"},{"text":"Uses: linked_node_mod module~~bidir_node_mod~~UsesGraph module~bidir_node_mod bidir_node_mod module~linked_node_mod linked_node_mod module~linked_node_mod->module~bidir_node_mod module~node_mod node_mod module~node_mod->module~linked_node_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~node_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Implements a node which contains a pointer to two other (the next \n and previous) nodes, allowing a chain to be formed. This can be used\n to, for example, build a doubly-linked lists. It is not anticipated that the bidir_node type, or any types \n extending it, will be handled directly by end users of FIAT; they \n are meant for internal use within this package. Derived Types type, public, extends(linked_node) :: bidir_node Components Type Visibility Attributes Name Initial class( bidir_node ), private, pointer :: prev => null() Type-Bound Procedures procedure, public :: has_prev procedure, public :: get_prev procedure, public :: set_prev procedure, public :: unset_prev Description A node which, in addition to holding a value, points at two other\n (the previous and next) bidir_node objects or objects of a\n descendent type. This type can be built up into a chain, allowing\n a doubly-linked list to be formed. Functions private elemental function has_prev (this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not this node points to a previous one, forming\n a chain in the backwards direction. private function get_prev (this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value class( bidir_node ),\n  pointer Description Author Chris MacMackin Date February 2016 Returns a pointer to the previous node in the chain. If this node\n does not point at a previous one one, then a null pointer is\n returned. Subroutines private subroutine set_prev (this, new_prev, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this class( bidir_node ), intent(in), pointer :: new_prev The node which will now be previous in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n previous nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Sets the pointer to the previous node in the chain. If this node\n already points to a previous one, the pointer will, by default, be\n nullified. This may result in a memory leak. Optionally, by\n setting deallocate_old=.true. , the previous node (and all nodes\n it points to) can be deallocated. This may result in a segfault if\n another part of the program tries to access the former previous\n node. The new previous node will not automatically be set to have\n this one as the next, with the same rules applied to deallocation. private subroutine unset_prev (this, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n p nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Unsets the pointer to the previous node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n previous node (and all previous nodes it points to) can be\n deallocated. This may result in a segfault if another part of the\n program tries to access the former previous node.","tags":"","loc":"module/bidir_node_mod.html","title":"bidir_node_mod – FIAT"},{"text":"Uses: abstract_container_mod iso_fortran_env module~~container_mod~~UsesGraph module~container_mod container_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~container_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~container_mod iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides implementations of the container abstract\n derived type for all of the intrinsic variable types. Derived Types type, public, extends(container) :: int_container Type-Bound Procedures procedure, private :: typeguard => int_guard Description A container for holding the defualt integer type. type, public, extends(container) :: int1_container Type-Bound Procedures procedure, private :: typeguard => int1_guard Description A container for holding the 1 byte integer type. type, public, extends(container) :: int2_container Type-Bound Procedures procedure, private :: typeguard => int2_guard Description A container for holding the 2 byte integer type. type, public, extends(container) :: int4_container Type-Bound Procedures procedure, private :: typeguard => int4_guard Description A container for holding the 4 byte integer type. type, public, extends(container) :: int8_container Type-Bound Procedures procedure, private :: typeguard => int8_guard Description A container for holding the 8 byte integer type. type, public, extends(container) :: real_container Type-Bound Procedures procedure, private :: typeguard => real_guard Description A container for holding the defualt real type. type, public, extends(container) :: real4_container Type-Bound Procedures procedure, private :: typeguard => real4_guard Description A container for holding the 4 byte real type. type, public, extends(container) :: real8_container Type-Bound Procedures procedure, private :: typeguard => real8_guard Description A container for holding the 8 byte real type. type, public, extends(container) :: real16_container Type-Bound Procedures procedure, private :: typeguard => real16_guard Description A container for holding the 16 byte real type. type, public, extends(container) :: complex_container Type-Bound Procedures procedure, private :: typeguard => complex_guard Description A container for holding the defualt complex type. type, public, extends(container) :: complex4_container Type-Bound Procedures procedure, private :: typeguard => complex4_guard Description A container for holding the 4 byte complex type. type, public, extends(container) :: complex8_container Type-Bound Procedures procedure, private :: typeguard => complex8_guard Description A container for holding the 8 byte complex type. type, public, extends(container) :: complex16_container Type-Bound Procedures procedure, private :: typeguard => complex16_guard Description A container for holding the 16 byte complex type. type, public, extends(container) :: logical_container Type-Bound Procedures procedure, private :: typeguard => logical_guard Description A container for holding the defualt logical type. type, public, extends(container) :: character_container Type-Bound Procedures procedure, private :: typeguard => character_guard Description A container for holding the defualt character type. Functions private function int_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function int1_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int1_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function int2_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int2_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function int4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function int8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function real_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function real4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function real8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function real16_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function complex_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function complex4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function complex8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function complex16_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function logical_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( logical_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function character_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( character_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type.","tags":"","loc":"module/container_mod.html","title":"container_mod – FIAT"},{"text":"Uses: iterator_mod module~~countable_mod~~UsesGraph module~countable_mod countable_mod module~iterator_mod iterator_mod module~iterator_mod->module~countable_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~iterator_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~countable_mod~~UsedByGraph module~countable_mod countable_mod module~ordered_mod ordered_mod module~countable_mod->module~ordered_mod module~stack_mod stack_mod module~ordered_mod->module~stack_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private function int_func (this) Arguments Type Intent Optional Attributes Name class( countable ), intent(in) :: this Return Value integer Derived Types type, public, abstract, extends(iterator) :: countable Type-Bound Procedures procedure(int_func), public, deferred :: size","tags":"","loc":"module/countable_mod.html","title":"countable_mod – FIAT"},{"text":"Uses: abstract_container_mod module~~iterator_mod~~UsesGraph module~iterator_mod iterator_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~iterator_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~iterator_mod~~UsedByGraph module~iterator_mod iterator_mod module~countable_mod countable_mod module~iterator_mod->module~countable_mod module~stack_mod stack_mod module~iterator_mod->module~stack_mod module~ordered_mod ordered_mod module~iterator_mod->module~ordered_mod module~countable_mod->module~ordered_mod module~ordered_mod->module~stack_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private subroutine empty_sub (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this abstract interface private elemental function has_func (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value logical abstract interface private function next_func (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this Return Value class( container ),\n  allocatable abstract interface private function copy_func (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value class( iterator ),\n  allocatable Derived Types type, public, abstract :: iterator Type-Bound Procedures procedure(has_func), public, deferred :: has_next procedure(next_func), public, deferred :: next procedure(empty_sub), public, deferred :: reset procedure(copy_func), public, deferred :: copy","tags":"","loc":"module/iterator_mod.html","title":"iterator_mod – FIAT"},{"text":"Uses: node_mod module~~linked_node_mod~~UsesGraph module~linked_node_mod linked_node_mod module~node_mod node_mod module~node_mod->module~linked_node_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~node_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Implements a node which contains a pointer to another (the next) \n node, allowing a chain to be formed. This can be used to, for\n example, build linked lists. It is not anticipated that the linked_node type, or any types \n extending it, will be handled directly by end users of FIAT; they \n are meant for internal use within this package. Used By module~~linked_node_mod~~UsedByGraph module~linked_node_mod linked_node_mod module~stack_mod stack_mod module~linked_node_mod->module~stack_mod module~bidir_node_mod bidir_node_mod module~linked_node_mod->module~bidir_node_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(node) :: linked_node Components Type Visibility Attributes Name Initial class( linked_node ), private, pointer :: next => null() The next node in the chain. Type-Bound Procedures procedure, public :: has_next Checks whether this node points to another one procedure, public :: get_next Returns the next node in the chain if it exists. procedure, public :: set_next Sets the next node in the chain. procedure, public :: unset_next Sets this node not to point at any others, severing the chain. Description A node which, in addition to holding a value, points at another\n (the next) linked_node or descendent type. This type can be built\n up into a chain, allowing a linked list to be formed. Functions private elemental function has_next (this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not this node points at another one, forming\n a chain. private function get_next (this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value class( linked_node ),\n  pointer Description Author Chris MacMackin Date February 2016 Returns a pointer to the node which this ones points to, i.e. the\n next node in the chain. If this node does not point at another \n one, then a null pointer is returned. Subroutines private subroutine set_next (this, new_next, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this class( linked_node ), intent(in), pointer :: new_next The node which will now be next in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Sets the node which this one points to (i.e. sets the next node in\n the chain). If this node already points to another one, the \n pointer will, by default, be nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node. private subroutine unset_next (this, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Unsets the pointer to the next node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node.","tags":"","loc":"module/linked_node_mod.html","title":"linked_node_mod – FIAT"},{"text":"Uses: abstract_container_mod module~~node_mod~~UsesGraph module~node_mod node_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~node_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides a node data type, for holding some sort of contents.\n While a node itself is unlikely to be very useful, various type\n extensions are also made which are then used to build more complex\n data structures. It is not anticipated that the node type, or any types extending it,\n will be handled directly by end users of FIAT; they are meant for\n internal use within this package. Used By module~~node_mod~~UsedByGraph module~node_mod node_mod module~linked_node_mod linked_node_mod module~node_mod->module~linked_node_mod module~stack_mod stack_mod module~linked_node_mod->module~stack_mod module~bidir_node_mod bidir_node_mod module~linked_node_mod->module~bidir_node_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: node Components Type Visibility Attributes Name Initial class( container ), private, allocatable :: contents Contains the value held in this node. Type-Bound Procedures procedure, public, non_overridable :: has_contents Evaluates whether contents have been assigned to node. procedure, public, non_overridable :: get_contents Returns the value stored in the node. procedure, public, non_overridable :: set_contents Sets the value to be stored in the node. procedure, public, non_overridable :: unset_contents Removes the record of any value stored in the node. Description An object which contains a container that can be set to have\n arbitrary contents. While of limited use on its own, various\n derived types exist which are extensions of this one exist and\n are used to build more complex data structures. Functions private elemental function has_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not a values has been assigned to the node. private pure function get_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value class( container ),\n  allocatable The stored in the node. Description Author Chris MacMackin Date February 2016 An accessor returning a container object storing the value\n placed in the node. If the contents have not been set then an\n unallocated container is returned. Subroutines private subroutine set_contents (this, contents) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this class( container ), intent(inout), allocatable :: contents The new value to be stored in this node. The actual argument\n will be deallocated during the process of assigning it to the\n node. Description Author Chris MacMackin Date February 2016 Places a new value into storage within the node. This value must\n already be heald within an allocatable container . The actual\n argument will be deallocated after the subroutine call, as its\n allocation is moved to the contents of the node. private subroutine unset_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this Description Author Chris MacMackin Date February 2016 Deallocates the value stored within the  node.","tags":"","loc":"module/node_mod.html","title":"node_mod – FIAT"},{"text":"Uses: iterator_mod countable_mod abstract_container_mod module~~ordered_mod~~UsesGraph module~ordered_mod ordered_mod module~countable_mod countable_mod module~countable_mod->module~ordered_mod module~iterator_mod iterator_mod module~iterator_mod->module~ordered_mod module~iterator_mod->module~countable_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~ordered_mod module~abstract_container_mod->module~iterator_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~ordered_mod~~UsedByGraph module~ordered_mod ordered_mod module~stack_mod stack_mod module~ordered_mod->module~stack_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private subroutine push_sub (this, item) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in) :: item abstract interface private subroutine blank_sub (this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this abstract interface private function pop_func (this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this Return Value class( container ),\n  allocatable abstract interface private function peek_func (this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: this Return Value class( container ),\n  allocatable abstract interface private function concat_func (lhs, rhs) Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: lhs class( ordered ), intent(in) :: rhs Return Value class( ordered ),\n  allocatable Derived Types type, public, abstract, extends(countable) :: ordered Type-Bound Procedures procedure(push_sub), public, deferred :: push procedure(pop_func), public, deferred :: pop procedure(peek_func), public, deferred :: peek procedure(blank_sub), public, deferred :: clear procedure, private :: array_extend procedure, private :: iterator_extend generic, public :: extend => array_extend, iterator_extend Subroutines private subroutine array_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in), dimension(:) :: items private subroutine iterator_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class( iterator ), intent(inout) :: items","tags":"","loc":"module/ordered_mod.html","title":"ordered_mod – FIAT"},{"text":"Uses: iso_fortran_env iterator_mod ordered_mod abstract_container_mod linked_node_mod module~~stack_mod~~UsesGraph module~stack_mod stack_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~stack_mod module~abstract_container_mod abstract_container_mod iso_fortran_env->module~abstract_container_mod module~linked_node_mod linked_node_mod module~linked_node_mod->module~stack_mod module~abstract_container_mod->module~stack_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~ordered_mod ordered_mod module~abstract_container_mod->module~ordered_mod module~node_mod node_mod module~abstract_container_mod->module~node_mod module~iterator_mod->module~stack_mod module~iterator_mod->module~ordered_mod module~countable_mod countable_mod module~iterator_mod->module~countable_mod module~ordered_mod->module~stack_mod module~node_mod->module~linked_node_mod module~countable_mod->module~ordered_mod var panmodulestack_modUsesGraph = svgPanZoom('#modulestack_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces private interface stack private function constructor (container_obj) result(new) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: container_obj Return Value type( stack ) Derived Types type, public, extends(ordered) :: stack Components Type Visibility Attributes Name Initial class( container ), private, allocatable :: container type( linked_node ), private, pointer :: head => null() type( linked_node ), private, pointer :: iter_pos => null() integer, private :: num_nodes = 0 Constructor private  function constructor (container_obj) Finalizations Procedures final :: stack_final","tags":"","loc":"module/stack_mod.html","title":"stack_mod – FIAT"}]}